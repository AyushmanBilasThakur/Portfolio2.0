{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport './polyfills';\nimport '#cache/runtime-polyfills';\nimport Vue from 'vue';\nimport Meta from 'vue-meta';\nimport layouts from '#cache/layouts';\nimport createRouter from './router';\nimport Layout from './components/LayoutManager.vue';\nimport ClientOnly from './components/ClientOnly';\nimport SaberLink from './components/SaberLink';\nimport extendBrowserApi from '#cache/extend-browser-api';\nimport { join, dirname } from './helpers/path';\nimport injectConfig from './helpers/inject-config';\nimport setTransition from './helpers/set-transition';\nimport scrollHandler from './helpers/scroll-handler';\nVue.config.productionTip = false;\nVue.component(ClientOnly.name, ClientOnly);\nVue.component(Layout.name, Layout);\nVue.component(SaberLink.name, SaberLink);\nVue.use(Meta, {\n  keyName: 'head',\n  attribute: 'data-saber-head',\n  ssrAttribute: 'data-saber-ssr',\n  tagIDKeyName: 'vmid'\n});\nVue.mixin({\n  beforeCreate: function beforeCreate() {\n    this.$saber = this.$root;\n  }\n});\nexport default (function (context) {\n  var router = createRouter();\n  var customHead;\n  var customRootComponent;\n  var rootOptions = {\n    mixins: [],\n    head: function head() {\n      var head = typeof customHead === 'function' ? customHead.call(this, this) : customHead || {};\n\n      var htmlAttrs = _objectSpread({\n        lang: this.$siteConfig.lang\n      }, head.htmlAttrs);\n\n      if (!htmlAttrs.lang) {\n        delete htmlAttrs.lang;\n      }\n\n      return _objectSpread({}, head, {\n        htmlAttrs: htmlAttrs,\n        meta: [{\n          name: 'generator',\n          content: \"Saber v\".concat(__SABER_VERSION__)\n        }].concat(_toConsumableArray(head.meta || []))\n      });\n    },\n    provide: {\n      layouts: layouts\n    },\n    layouts: layouts,\n    router: router,\n    data: function data() {\n      return {\n        transition: null\n      };\n    },\n    mounted: function mounted() {\n      scrollHandler(this.$router, this.$router.currentRoute, this.$router.currentRoute);\n    },\n    render: function render(h) {\n      var _this = this;\n\n      var transition = Object.assign({}, this.transition);\n      var listeners = {};\n      Object.keys(transition).forEach(function (key) {\n        if (typeof transition[key] === 'function') {\n          var kebabKey = key.replace(/([a-z])([A-Z])/, function (_, p1, p2) {\n            return \"\".concat(p1, \"-\").concat(p2.toLowerCase());\n          });\n          listeners[kebabKey] = transition[key];\n          delete transition[key];\n        }\n      });\n      var beforeEnter = listeners['before-enter'];\n\n      listeners['before-enter'] = function (el) {\n        _this.$nextTick(function () {\n          _this.$emit('trigger-scroll');\n        });\n\n        beforeEnter && beforeEnter(el);\n      };\n\n      var children = [h('transition', {\n        props: transition,\n        on: listeners\n      }, [h('router-view')])];\n      return h('div', {\n        attrs: {\n          id: '_saber'\n        }\n      }, [customRootComponent ? h(customRootComponent, {}, children) : children]);\n    },\n    methods: {\n      setTransition: function setTransition(name) {\n        this.transition = name;\n      },\n      getPageLink: function getPageLink(link) {\n        if (typeof link !== 'string' && process.env.NODE_ENV !== 'production') {\n          throw new TypeError(\"Expect link to be a string\");\n        }\n\n        var matched = /^([^#?]+)([#?].*)?$/.exec(link);\n\n        if (!matched) {\n          return link;\n        }\n\n        var relativePath = join(dirname(this.$route.meta.__relative), matched[1]);\n        var extra = matched[2] || '';\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.$router.options.routes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var route = _step.value;\n\n            if (route.path === matched[1]) {\n              return link;\n            }\n\n            if (route.meta && route.meta.__relative && relativePath === route.meta.__relative) {\n              return \"\".concat(route.path).concat(extra);\n            }\n          } // Not a page\n\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return undefined;\n      }\n    }\n  };\n\n  var setHead = function setHead(input) {\n    return customHead = input;\n  };\n\n  var setRootComponent = function setRootComponent(input) {\n    return customRootComponent = input;\n  };\n\n  var browserApiContext = {\n    Vue: Vue,\n    router: router,\n    rootOptions: rootOptions,\n    setHead: setHead,\n    setRootComponent: setRootComponent\n  };\n  injectConfig(browserApiContext);\n  extendBrowserApi(browserApiContext); // Set transition after calling `extendBrowserApi`\n  // Because user might use `beforeEach` hook to add progress bar\n\n  setTransition(browserApiContext);\n  var app = new Vue(rootOptions);\n  return {\n    app: app,\n    router: router\n  };\n}); // Reloading browser when following files change\n\nif (module.hot) {\n  module.hot.accept(['#cache/layouts', '#cache/runtime-polyfills'], function () {\n    location.reload();\n  });\n}","map":null,"metadata":{},"sourceType":"module"}